// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MESSAGE_H_
#define FLATBUFFERS_GENERATED_MESSAGE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct Vec3;

struct Vec4;

struct ObjectProperties;
struct ObjectPropertiesBuilder;

struct ModelCreateRequest;
struct ModelCreateRequestBuilder;

struct SphereCreateRequest;
struct SphereCreateRequestBuilder;

struct BoxCreateRequest;
struct BoxCreateRequestBuilder;

struct Matrix;
struct MatrixBuilder;

struct UpdatedObjectProperties;
struct UpdatedObjectPropertiesBuilder;

struct ModelUpdateRequest;
struct ModelUpdateRequestBuilder;

struct SphereUpdateRequest;
struct SphereUpdateRequestBuilder;

struct BoxUpdateRequest;
struct BoxUpdateRequestBuilder;

struct ObjectCreateRequest;
struct ObjectCreateRequestBuilder;

struct ObjectCreateAndUpdateRequest;
struct ObjectCreateAndUpdateRequestBuilder;

struct ObjectUpdateRequest;
struct ObjectUpdateRequestBuilder;

struct ObjectPropertiesUpdateRequest;
struct ObjectPropertiesUpdateRequestBuilder;

struct ObjectDebugRequest;
struct ObjectDebugRequestBuilder;

struct Message;
struct MessageBuilder;

enum ObjectCreateRequestUnion : uint8_t {
  ObjectCreateRequestUnion_NONE = 0,
  ObjectCreateRequestUnion_ModelCreateRequest = 1,
  ObjectCreateRequestUnion_SphereCreateRequest = 2,
  ObjectCreateRequestUnion_BoxCreateRequest = 3,
  ObjectCreateRequestUnion_MIN = ObjectCreateRequestUnion_NONE,
  ObjectCreateRequestUnion_MAX = ObjectCreateRequestUnion_BoxCreateRequest
};

inline const ObjectCreateRequestUnion (&EnumValuesObjectCreateRequestUnion())[4] {
  static const ObjectCreateRequestUnion values[] = {
    ObjectCreateRequestUnion_NONE,
    ObjectCreateRequestUnion_ModelCreateRequest,
    ObjectCreateRequestUnion_SphereCreateRequest,
    ObjectCreateRequestUnion_BoxCreateRequest
  };
  return values;
}

inline const char * const *EnumNamesObjectCreateRequestUnion() {
  static const char * const names[5] = {
    "NONE",
    "ModelCreateRequest",
    "SphereCreateRequest",
    "BoxCreateRequest",
    nullptr
  };
  return names;
}

inline const char *EnumNameObjectCreateRequestUnion(ObjectCreateRequestUnion e) {
  if (::flatbuffers::IsOutRange(e, ObjectCreateRequestUnion_NONE, ObjectCreateRequestUnion_BoxCreateRequest)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesObjectCreateRequestUnion()[index];
}

template<typename T> struct ObjectCreateRequestUnionTraits {
  static const ObjectCreateRequestUnion enum_value = ObjectCreateRequestUnion_NONE;
};

template<> struct ObjectCreateRequestUnionTraits<ModelCreateRequest> {
  static const ObjectCreateRequestUnion enum_value = ObjectCreateRequestUnion_ModelCreateRequest;
};

template<> struct ObjectCreateRequestUnionTraits<SphereCreateRequest> {
  static const ObjectCreateRequestUnion enum_value = ObjectCreateRequestUnion_SphereCreateRequest;
};

template<> struct ObjectCreateRequestUnionTraits<BoxCreateRequest> {
  static const ObjectCreateRequestUnion enum_value = ObjectCreateRequestUnion_BoxCreateRequest;
};

bool VerifyObjectCreateRequestUnion(::flatbuffers::Verifier &verifier, const void *obj, ObjectCreateRequestUnion type);
bool VerifyObjectCreateRequestUnionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum ObjectUpdateRequestUnion : uint8_t {
  ObjectUpdateRequestUnion_NONE = 0,
  ObjectUpdateRequestUnion_ModelUpdateRequest = 1,
  ObjectUpdateRequestUnion_SphereUpdateRequest = 2,
  ObjectUpdateRequestUnion_BoxUpdateRequest = 3,
  ObjectUpdateRequestUnion_MIN = ObjectUpdateRequestUnion_NONE,
  ObjectUpdateRequestUnion_MAX = ObjectUpdateRequestUnion_BoxUpdateRequest
};

inline const ObjectUpdateRequestUnion (&EnumValuesObjectUpdateRequestUnion())[4] {
  static const ObjectUpdateRequestUnion values[] = {
    ObjectUpdateRequestUnion_NONE,
    ObjectUpdateRequestUnion_ModelUpdateRequest,
    ObjectUpdateRequestUnion_SphereUpdateRequest,
    ObjectUpdateRequestUnion_BoxUpdateRequest
  };
  return values;
}

inline const char * const *EnumNamesObjectUpdateRequestUnion() {
  static const char * const names[5] = {
    "NONE",
    "ModelUpdateRequest",
    "SphereUpdateRequest",
    "BoxUpdateRequest",
    nullptr
  };
  return names;
}

inline const char *EnumNameObjectUpdateRequestUnion(ObjectUpdateRequestUnion e) {
  if (::flatbuffers::IsOutRange(e, ObjectUpdateRequestUnion_NONE, ObjectUpdateRequestUnion_BoxUpdateRequest)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesObjectUpdateRequestUnion()[index];
}

template<typename T> struct ObjectUpdateRequestUnionTraits {
  static const ObjectUpdateRequestUnion enum_value = ObjectUpdateRequestUnion_NONE;
};

template<> struct ObjectUpdateRequestUnionTraits<ModelUpdateRequest> {
  static const ObjectUpdateRequestUnion enum_value = ObjectUpdateRequestUnion_ModelUpdateRequest;
};

template<> struct ObjectUpdateRequestUnionTraits<SphereUpdateRequest> {
  static const ObjectUpdateRequestUnion enum_value = ObjectUpdateRequestUnion_SphereUpdateRequest;
};

template<> struct ObjectUpdateRequestUnionTraits<BoxUpdateRequest> {
  static const ObjectUpdateRequestUnion enum_value = ObjectUpdateRequestUnion_BoxUpdateRequest;
};

bool VerifyObjectUpdateRequestUnion(::flatbuffers::Verifier &verifier, const void *obj, ObjectUpdateRequestUnion type);
bool VerifyObjectUpdateRequestUnionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum MessageUnion : uint8_t {
  MessageUnion_NONE = 0,
  MessageUnion_ObjectCreateRequest = 1,
  MessageUnion_ObjectCreateAndUpdateRequest = 2,
  MessageUnion_ObjectUpdateRequest = 3,
  MessageUnion_ObjectPropertiesUpdateRequest = 4,
  MessageUnion_ObjectDebugRequest = 5,
  MessageUnion_MIN = MessageUnion_NONE,
  MessageUnion_MAX = MessageUnion_ObjectDebugRequest
};

inline const MessageUnion (&EnumValuesMessageUnion())[6] {
  static const MessageUnion values[] = {
    MessageUnion_NONE,
    MessageUnion_ObjectCreateRequest,
    MessageUnion_ObjectCreateAndUpdateRequest,
    MessageUnion_ObjectUpdateRequest,
    MessageUnion_ObjectPropertiesUpdateRequest,
    MessageUnion_ObjectDebugRequest
  };
  return values;
}

inline const char * const *EnumNamesMessageUnion() {
  static const char * const names[7] = {
    "NONE",
    "ObjectCreateRequest",
    "ObjectCreateAndUpdateRequest",
    "ObjectUpdateRequest",
    "ObjectPropertiesUpdateRequest",
    "ObjectDebugRequest",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessageUnion(MessageUnion e) {
  if (::flatbuffers::IsOutRange(e, MessageUnion_NONE, MessageUnion_ObjectDebugRequest)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessageUnion()[index];
}

template<typename T> struct MessageUnionTraits {
  static const MessageUnion enum_value = MessageUnion_NONE;
};

template<> struct MessageUnionTraits<ObjectCreateRequest> {
  static const MessageUnion enum_value = MessageUnion_ObjectCreateRequest;
};

template<> struct MessageUnionTraits<ObjectCreateAndUpdateRequest> {
  static const MessageUnion enum_value = MessageUnion_ObjectCreateAndUpdateRequest;
};

template<> struct MessageUnionTraits<ObjectUpdateRequest> {
  static const MessageUnion enum_value = MessageUnion_ObjectUpdateRequest;
};

template<> struct MessageUnionTraits<ObjectPropertiesUpdateRequest> {
  static const MessageUnion enum_value = MessageUnion_ObjectPropertiesUpdateRequest;
};

template<> struct MessageUnionTraits<ObjectDebugRequest> {
  static const MessageUnion enum_value = MessageUnion_ObjectDebugRequest;
};

bool VerifyMessageUnion(::flatbuffers::Verifier &verifier, const void *obj, MessageUnion type);
bool VerifyMessageUnionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vec3()
      : x_(0),
        y_(0),
        z_(0) {
  }
  Vec3(float _x, float _y, float _z)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)),
        z_(::flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return ::flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Vec3, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec4 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  Vec4()
      : x_(0),
        y_(0),
        z_(0),
        w_(0) {
  }
  Vec4(float _x, float _y, float _z, float _w)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)),
        z_(::flatbuffers::EndianScalar(_z)),
        w_(::flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return ::flatbuffers::EndianScalar(z_);
  }
  float w() const {
    return ::flatbuffers::EndianScalar(w_);
  }
};
FLATBUFFERS_STRUCT_END(Vec4, 16);

struct ObjectProperties FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ObjectPropertiesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_LOCATION = 6,
    VT_ROTATION = 8,
    VT_SCALE = 10
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const Vec3 *location() const {
    return GetStruct<const Vec3 *>(VT_LOCATION);
  }
  const Vec3 *rotation() const {
    return GetStruct<const Vec3 *>(VT_ROTATION);
  }
  float scale() const {
    return GetField<float>(VT_SCALE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<Vec3>(verifier, VT_LOCATION, 4) &&
           VerifyField<Vec3>(verifier, VT_ROTATION, 4) &&
           VerifyField<float>(verifier, VT_SCALE, 4) &&
           verifier.EndTable();
  }
};

struct ObjectPropertiesBuilder {
  typedef ObjectProperties Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(ObjectProperties::VT_ID, id);
  }
  void add_location(const Vec3 *location) {
    fbb_.AddStruct(ObjectProperties::VT_LOCATION, location);
  }
  void add_rotation(const Vec3 *rotation) {
    fbb_.AddStruct(ObjectProperties::VT_ROTATION, rotation);
  }
  void add_scale(float scale) {
    fbb_.AddElement<float>(ObjectProperties::VT_SCALE, scale, 0.0f);
  }
  explicit ObjectPropertiesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ObjectProperties> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ObjectProperties>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ObjectProperties> CreateObjectProperties(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    const Vec3 *location = nullptr,
    const Vec3 *rotation = nullptr,
    float scale = 0.0f) {
  ObjectPropertiesBuilder builder_(_fbb);
  builder_.add_scale(scale);
  builder_.add_rotation(rotation);
  builder_.add_location(location);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ObjectProperties> CreateObjectPropertiesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const Vec3 *location = nullptr,
    const Vec3 *rotation = nullptr,
    float scale = 0.0f) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  return CreateObjectProperties(
      _fbb,
      id__,
      location,
      rotation,
      scale);
}

struct ModelCreateRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ModelCreateRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FILE = 4,
    VT_FLAGS = 6,
    VT_FIRST_CHILD_ROOT = 8
  };
  const ::flatbuffers::String *file() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FILE);
  }
  uint32_t flags() const {
    return GetField<uint32_t>(VT_FLAGS, 0);
  }
  bool first_child_root() const {
    return GetField<uint8_t>(VT_FIRST_CHILD_ROOT, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FILE) &&
           verifier.VerifyString(file()) &&
           VerifyField<uint32_t>(verifier, VT_FLAGS, 4) &&
           VerifyField<uint8_t>(verifier, VT_FIRST_CHILD_ROOT, 1) &&
           verifier.EndTable();
  }
};

struct ModelCreateRequestBuilder {
  typedef ModelCreateRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_file(::flatbuffers::Offset<::flatbuffers::String> file) {
    fbb_.AddOffset(ModelCreateRequest::VT_FILE, file);
  }
  void add_flags(uint32_t flags) {
    fbb_.AddElement<uint32_t>(ModelCreateRequest::VT_FLAGS, flags, 0);
  }
  void add_first_child_root(bool first_child_root) {
    fbb_.AddElement<uint8_t>(ModelCreateRequest::VT_FIRST_CHILD_ROOT, static_cast<uint8_t>(first_child_root), 0);
  }
  explicit ModelCreateRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ModelCreateRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ModelCreateRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ModelCreateRequest> CreateModelCreateRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> file = 0,
    uint32_t flags = 0,
    bool first_child_root = false) {
  ModelCreateRequestBuilder builder_(_fbb);
  builder_.add_flags(flags);
  builder_.add_file(file);
  builder_.add_first_child_root(first_child_root);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ModelCreateRequest> CreateModelCreateRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *file = nullptr,
    uint32_t flags = 0,
    bool first_child_root = false) {
  auto file__ = file ? _fbb.CreateString(file) : 0;
  return CreateModelCreateRequest(
      _fbb,
      file__,
      flags,
      first_child_root);
}

struct SphereCreateRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SphereCreateRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RADIUS = 4,
    VT_COLOR = 6,
    VT_TEXTURE = 8
  };
  float radius() const {
    return GetField<float>(VT_RADIUS, 0.0f);
  }
  const Vec4 *color() const {
    return GetStruct<const Vec4 *>(VT_COLOR);
  }
  const ::flatbuffers::String *texture() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXTURE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_RADIUS, 4) &&
           VerifyField<Vec4>(verifier, VT_COLOR, 4) &&
           VerifyOffset(verifier, VT_TEXTURE) &&
           verifier.VerifyString(texture()) &&
           verifier.EndTable();
  }
};

struct SphereCreateRequestBuilder {
  typedef SphereCreateRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_radius(float radius) {
    fbb_.AddElement<float>(SphereCreateRequest::VT_RADIUS, radius, 0.0f);
  }
  void add_color(const Vec4 *color) {
    fbb_.AddStruct(SphereCreateRequest::VT_COLOR, color);
  }
  void add_texture(::flatbuffers::Offset<::flatbuffers::String> texture) {
    fbb_.AddOffset(SphereCreateRequest::VT_TEXTURE, texture);
  }
  explicit SphereCreateRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SphereCreateRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SphereCreateRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SphereCreateRequest> CreateSphereCreateRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float radius = 0.0f,
    const Vec4 *color = nullptr,
    ::flatbuffers::Offset<::flatbuffers::String> texture = 0) {
  SphereCreateRequestBuilder builder_(_fbb);
  builder_.add_texture(texture);
  builder_.add_color(color);
  builder_.add_radius(radius);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SphereCreateRequest> CreateSphereCreateRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float radius = 0.0f,
    const Vec4 *color = nullptr,
    const char *texture = nullptr) {
  auto texture__ = texture ? _fbb.CreateString(texture) : 0;
  return CreateSphereCreateRequest(
      _fbb,
      radius,
      color,
      texture__);
}

struct BoxCreateRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BoxCreateRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WIDTH = 4,
    VT_HEIGHT = 6,
    VT_DEPTH = 8,
    VT_COLOR = 10,
    VT_TEXTURE = 12
  };
  float width() const {
    return GetField<float>(VT_WIDTH, 0.0f);
  }
  float height() const {
    return GetField<float>(VT_HEIGHT, 0.0f);
  }
  float depth() const {
    return GetField<float>(VT_DEPTH, 0.0f);
  }
  const Vec4 *color() const {
    return GetStruct<const Vec4 *>(VT_COLOR);
  }
  const ::flatbuffers::String *texture() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXTURE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_WIDTH, 4) &&
           VerifyField<float>(verifier, VT_HEIGHT, 4) &&
           VerifyField<float>(verifier, VT_DEPTH, 4) &&
           VerifyField<Vec4>(verifier, VT_COLOR, 4) &&
           VerifyOffset(verifier, VT_TEXTURE) &&
           verifier.VerifyString(texture()) &&
           verifier.EndTable();
  }
};

struct BoxCreateRequestBuilder {
  typedef BoxCreateRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_width(float width) {
    fbb_.AddElement<float>(BoxCreateRequest::VT_WIDTH, width, 0.0f);
  }
  void add_height(float height) {
    fbb_.AddElement<float>(BoxCreateRequest::VT_HEIGHT, height, 0.0f);
  }
  void add_depth(float depth) {
    fbb_.AddElement<float>(BoxCreateRequest::VT_DEPTH, depth, 0.0f);
  }
  void add_color(const Vec4 *color) {
    fbb_.AddStruct(BoxCreateRequest::VT_COLOR, color);
  }
  void add_texture(::flatbuffers::Offset<::flatbuffers::String> texture) {
    fbb_.AddOffset(BoxCreateRequest::VT_TEXTURE, texture);
  }
  explicit BoxCreateRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BoxCreateRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BoxCreateRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BoxCreateRequest> CreateBoxCreateRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float width = 0.0f,
    float height = 0.0f,
    float depth = 0.0f,
    const Vec4 *color = nullptr,
    ::flatbuffers::Offset<::flatbuffers::String> texture = 0) {
  BoxCreateRequestBuilder builder_(_fbb);
  builder_.add_texture(texture);
  builder_.add_color(color);
  builder_.add_depth(depth);
  builder_.add_height(height);
  builder_.add_width(width);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BoxCreateRequest> CreateBoxCreateRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float width = 0.0f,
    float height = 0.0f,
    float depth = 0.0f,
    const Vec4 *color = nullptr,
    const char *texture = nullptr) {
  auto texture__ = texture ? _fbb.CreateString(texture) : 0;
  return CreateBoxCreateRequest(
      _fbb,
      width,
      height,
      depth,
      color,
      texture__);
}

struct Matrix FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MatrixBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COL0 = 4,
    VT_COL1 = 6,
    VT_COL2 = 8,
    VT_COL3 = 10
  };
  const Vec4 *col0() const {
    return GetStruct<const Vec4 *>(VT_COL0);
  }
  const Vec4 *col1() const {
    return GetStruct<const Vec4 *>(VT_COL1);
  }
  const Vec4 *col2() const {
    return GetStruct<const Vec4 *>(VT_COL2);
  }
  const Vec4 *col3() const {
    return GetStruct<const Vec4 *>(VT_COL3);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Vec4>(verifier, VT_COL0, 4) &&
           VerifyField<Vec4>(verifier, VT_COL1, 4) &&
           VerifyField<Vec4>(verifier, VT_COL2, 4) &&
           VerifyField<Vec4>(verifier, VT_COL3, 4) &&
           verifier.EndTable();
  }
};

struct MatrixBuilder {
  typedef Matrix Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_col0(const Vec4 *col0) {
    fbb_.AddStruct(Matrix::VT_COL0, col0);
  }
  void add_col1(const Vec4 *col1) {
    fbb_.AddStruct(Matrix::VT_COL1, col1);
  }
  void add_col2(const Vec4 *col2) {
    fbb_.AddStruct(Matrix::VT_COL2, col2);
  }
  void add_col3(const Vec4 *col3) {
    fbb_.AddStruct(Matrix::VT_COL3, col3);
  }
  explicit MatrixBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Matrix> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Matrix>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Matrix> CreateMatrix(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const Vec4 *col0 = nullptr,
    const Vec4 *col1 = nullptr,
    const Vec4 *col2 = nullptr,
    const Vec4 *col3 = nullptr) {
  MatrixBuilder builder_(_fbb);
  builder_.add_col3(col3);
  builder_.add_col2(col2);
  builder_.add_col1(col1);
  builder_.add_col0(col0);
  return builder_.Finish();
}

struct UpdatedObjectProperties FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UpdatedObjectPropertiesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_SPHERE_RADIUS = 6,
    VT_SPHERE_CENTER = 8,
    VT_MATRIX = 10,
    VT_ROTATION = 12,
    VT_SCALING = 14
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  float sphere_radius() const {
    return GetField<float>(VT_SPHERE_RADIUS, 0.0f);
  }
  const Vec3 *sphere_center() const {
    return GetStruct<const Vec3 *>(VT_SPHERE_CENTER);
  }
  const Matrix *matrix() const {
    return GetPointer<const Matrix *>(VT_MATRIX);
  }
  const Vec3 *rotation() const {
    return GetStruct<const Vec3 *>(VT_ROTATION);
  }
  float scaling() const {
    return GetField<float>(VT_SCALING, 1.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<float>(verifier, VT_SPHERE_RADIUS, 4) &&
           VerifyField<Vec3>(verifier, VT_SPHERE_CENTER, 4) &&
           VerifyOffset(verifier, VT_MATRIX) &&
           verifier.VerifyTable(matrix()) &&
           VerifyField<Vec3>(verifier, VT_ROTATION, 4) &&
           VerifyField<float>(verifier, VT_SCALING, 4) &&
           verifier.EndTable();
  }
};

struct UpdatedObjectPropertiesBuilder {
  typedef UpdatedObjectProperties Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(UpdatedObjectProperties::VT_ID, id);
  }
  void add_sphere_radius(float sphere_radius) {
    fbb_.AddElement<float>(UpdatedObjectProperties::VT_SPHERE_RADIUS, sphere_radius, 0.0f);
  }
  void add_sphere_center(const Vec3 *sphere_center) {
    fbb_.AddStruct(UpdatedObjectProperties::VT_SPHERE_CENTER, sphere_center);
  }
  void add_matrix(::flatbuffers::Offset<Matrix> matrix) {
    fbb_.AddOffset(UpdatedObjectProperties::VT_MATRIX, matrix);
  }
  void add_rotation(const Vec3 *rotation) {
    fbb_.AddStruct(UpdatedObjectProperties::VT_ROTATION, rotation);
  }
  void add_scaling(float scaling) {
    fbb_.AddElement<float>(UpdatedObjectProperties::VT_SCALING, scaling, 1.0f);
  }
  explicit UpdatedObjectPropertiesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UpdatedObjectProperties> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UpdatedObjectProperties>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UpdatedObjectProperties> CreateUpdatedObjectProperties(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    float sphere_radius = 0.0f,
    const Vec3 *sphere_center = nullptr,
    ::flatbuffers::Offset<Matrix> matrix = 0,
    const Vec3 *rotation = nullptr,
    float scaling = 1.0f) {
  UpdatedObjectPropertiesBuilder builder_(_fbb);
  builder_.add_scaling(scaling);
  builder_.add_rotation(rotation);
  builder_.add_matrix(matrix);
  builder_.add_sphere_center(sphere_center);
  builder_.add_sphere_radius(sphere_radius);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<UpdatedObjectProperties> CreateUpdatedObjectPropertiesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    float sphere_radius = 0.0f,
    const Vec3 *sphere_center = nullptr,
    ::flatbuffers::Offset<Matrix> matrix = 0,
    const Vec3 *rotation = nullptr,
    float scaling = 1.0f) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  return CreateUpdatedObjectProperties(
      _fbb,
      id__,
      sphere_radius,
      sphere_center,
      matrix,
      rotation,
      scaling);
}

struct ModelUpdateRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ModelUpdateRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UPDATES = 4,
    VT_FILE = 6,
    VT_ANIMATION = 8,
    VT_ANIMATION_TIME = 10,
    VT_FLAGS = 12,
    VT_FIRST_CHILD_ROOT = 14
  };
  const UpdatedObjectProperties *updates() const {
    return GetPointer<const UpdatedObjectProperties *>(VT_UPDATES);
  }
  const ::flatbuffers::String *file() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FILE);
  }
  const ::flatbuffers::String *animation() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ANIMATION);
  }
  float animation_time() const {
    return GetField<float>(VT_ANIMATION_TIME, 0.0f);
  }
  uint32_t flags() const {
    return GetField<uint32_t>(VT_FLAGS, 0);
  }
  bool first_child_root() const {
    return GetField<uint8_t>(VT_FIRST_CHILD_ROOT, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UPDATES) &&
           verifier.VerifyTable(updates()) &&
           VerifyOffset(verifier, VT_FILE) &&
           verifier.VerifyString(file()) &&
           VerifyOffset(verifier, VT_ANIMATION) &&
           verifier.VerifyString(animation()) &&
           VerifyField<float>(verifier, VT_ANIMATION_TIME, 4) &&
           VerifyField<uint32_t>(verifier, VT_FLAGS, 4) &&
           VerifyField<uint8_t>(verifier, VT_FIRST_CHILD_ROOT, 1) &&
           verifier.EndTable();
  }
};

struct ModelUpdateRequestBuilder {
  typedef ModelUpdateRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_updates(::flatbuffers::Offset<UpdatedObjectProperties> updates) {
    fbb_.AddOffset(ModelUpdateRequest::VT_UPDATES, updates);
  }
  void add_file(::flatbuffers::Offset<::flatbuffers::String> file) {
    fbb_.AddOffset(ModelUpdateRequest::VT_FILE, file);
  }
  void add_animation(::flatbuffers::Offset<::flatbuffers::String> animation) {
    fbb_.AddOffset(ModelUpdateRequest::VT_ANIMATION, animation);
  }
  void add_animation_time(float animation_time) {
    fbb_.AddElement<float>(ModelUpdateRequest::VT_ANIMATION_TIME, animation_time, 0.0f);
  }
  void add_flags(uint32_t flags) {
    fbb_.AddElement<uint32_t>(ModelUpdateRequest::VT_FLAGS, flags, 0);
  }
  void add_first_child_root(bool first_child_root) {
    fbb_.AddElement<uint8_t>(ModelUpdateRequest::VT_FIRST_CHILD_ROOT, static_cast<uint8_t>(first_child_root), 0);
  }
  explicit ModelUpdateRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ModelUpdateRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ModelUpdateRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ModelUpdateRequest> CreateModelUpdateRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<UpdatedObjectProperties> updates = 0,
    ::flatbuffers::Offset<::flatbuffers::String> file = 0,
    ::flatbuffers::Offset<::flatbuffers::String> animation = 0,
    float animation_time = 0.0f,
    uint32_t flags = 0,
    bool first_child_root = false) {
  ModelUpdateRequestBuilder builder_(_fbb);
  builder_.add_flags(flags);
  builder_.add_animation_time(animation_time);
  builder_.add_animation(animation);
  builder_.add_file(file);
  builder_.add_updates(updates);
  builder_.add_first_child_root(first_child_root);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ModelUpdateRequest> CreateModelUpdateRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<UpdatedObjectProperties> updates = 0,
    const char *file = nullptr,
    const char *animation = nullptr,
    float animation_time = 0.0f,
    uint32_t flags = 0,
    bool first_child_root = false) {
  auto file__ = file ? _fbb.CreateString(file) : 0;
  auto animation__ = animation ? _fbb.CreateString(animation) : 0;
  return CreateModelUpdateRequest(
      _fbb,
      updates,
      file__,
      animation__,
      animation_time,
      flags,
      first_child_root);
}

struct SphereUpdateRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SphereUpdateRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UPDATES = 4,
    VT_RADIUS = 6,
    VT_COLOR = 8,
    VT_TEXTURE = 10
  };
  const UpdatedObjectProperties *updates() const {
    return GetPointer<const UpdatedObjectProperties *>(VT_UPDATES);
  }
  float radius() const {
    return GetField<float>(VT_RADIUS, 0.0f);
  }
  const Vec4 *color() const {
    return GetStruct<const Vec4 *>(VT_COLOR);
  }
  const ::flatbuffers::String *texture() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXTURE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UPDATES) &&
           verifier.VerifyTable(updates()) &&
           VerifyField<float>(verifier, VT_RADIUS, 4) &&
           VerifyField<Vec4>(verifier, VT_COLOR, 4) &&
           VerifyOffset(verifier, VT_TEXTURE) &&
           verifier.VerifyString(texture()) &&
           verifier.EndTable();
  }
};

struct SphereUpdateRequestBuilder {
  typedef SphereUpdateRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_updates(::flatbuffers::Offset<UpdatedObjectProperties> updates) {
    fbb_.AddOffset(SphereUpdateRequest::VT_UPDATES, updates);
  }
  void add_radius(float radius) {
    fbb_.AddElement<float>(SphereUpdateRequest::VT_RADIUS, radius, 0.0f);
  }
  void add_color(const Vec4 *color) {
    fbb_.AddStruct(SphereUpdateRequest::VT_COLOR, color);
  }
  void add_texture(::flatbuffers::Offset<::flatbuffers::String> texture) {
    fbb_.AddOffset(SphereUpdateRequest::VT_TEXTURE, texture);
  }
  explicit SphereUpdateRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SphereUpdateRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SphereUpdateRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SphereUpdateRequest> CreateSphereUpdateRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<UpdatedObjectProperties> updates = 0,
    float radius = 0.0f,
    const Vec4 *color = nullptr,
    ::flatbuffers::Offset<::flatbuffers::String> texture = 0) {
  SphereUpdateRequestBuilder builder_(_fbb);
  builder_.add_texture(texture);
  builder_.add_color(color);
  builder_.add_radius(radius);
  builder_.add_updates(updates);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SphereUpdateRequest> CreateSphereUpdateRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<UpdatedObjectProperties> updates = 0,
    float radius = 0.0f,
    const Vec4 *color = nullptr,
    const char *texture = nullptr) {
  auto texture__ = texture ? _fbb.CreateString(texture) : 0;
  return CreateSphereUpdateRequest(
      _fbb,
      updates,
      radius,
      color,
      texture__);
}

struct BoxUpdateRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BoxUpdateRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UPDATES = 4,
    VT_WIDTH = 6,
    VT_HEIGHT = 8,
    VT_DEPTH = 10,
    VT_COLOR = 12,
    VT_TEXTURE = 14
  };
  const UpdatedObjectProperties *updates() const {
    return GetPointer<const UpdatedObjectProperties *>(VT_UPDATES);
  }
  float width() const {
    return GetField<float>(VT_WIDTH, 0.0f);
  }
  float height() const {
    return GetField<float>(VT_HEIGHT, 0.0f);
  }
  float depth() const {
    return GetField<float>(VT_DEPTH, 0.0f);
  }
  const Vec4 *color() const {
    return GetStruct<const Vec4 *>(VT_COLOR);
  }
  const ::flatbuffers::String *texture() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXTURE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UPDATES) &&
           verifier.VerifyTable(updates()) &&
           VerifyField<float>(verifier, VT_WIDTH, 4) &&
           VerifyField<float>(verifier, VT_HEIGHT, 4) &&
           VerifyField<float>(verifier, VT_DEPTH, 4) &&
           VerifyField<Vec4>(verifier, VT_COLOR, 4) &&
           VerifyOffset(verifier, VT_TEXTURE) &&
           verifier.VerifyString(texture()) &&
           verifier.EndTable();
  }
};

struct BoxUpdateRequestBuilder {
  typedef BoxUpdateRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_updates(::flatbuffers::Offset<UpdatedObjectProperties> updates) {
    fbb_.AddOffset(BoxUpdateRequest::VT_UPDATES, updates);
  }
  void add_width(float width) {
    fbb_.AddElement<float>(BoxUpdateRequest::VT_WIDTH, width, 0.0f);
  }
  void add_height(float height) {
    fbb_.AddElement<float>(BoxUpdateRequest::VT_HEIGHT, height, 0.0f);
  }
  void add_depth(float depth) {
    fbb_.AddElement<float>(BoxUpdateRequest::VT_DEPTH, depth, 0.0f);
  }
  void add_color(const Vec4 *color) {
    fbb_.AddStruct(BoxUpdateRequest::VT_COLOR, color);
  }
  void add_texture(::flatbuffers::Offset<::flatbuffers::String> texture) {
    fbb_.AddOffset(BoxUpdateRequest::VT_TEXTURE, texture);
  }
  explicit BoxUpdateRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BoxUpdateRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BoxUpdateRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BoxUpdateRequest> CreateBoxUpdateRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<UpdatedObjectProperties> updates = 0,
    float width = 0.0f,
    float height = 0.0f,
    float depth = 0.0f,
    const Vec4 *color = nullptr,
    ::flatbuffers::Offset<::flatbuffers::String> texture = 0) {
  BoxUpdateRequestBuilder builder_(_fbb);
  builder_.add_texture(texture);
  builder_.add_color(color);
  builder_.add_depth(depth);
  builder_.add_height(height);
  builder_.add_width(width);
  builder_.add_updates(updates);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BoxUpdateRequest> CreateBoxUpdateRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<UpdatedObjectProperties> updates = 0,
    float width = 0.0f,
    float height = 0.0f,
    float depth = 0.0f,
    const Vec4 *color = nullptr,
    const char *texture = nullptr) {
  auto texture__ = texture ? _fbb.CreateString(texture) : 0;
  return CreateBoxUpdateRequest(
      _fbb,
      updates,
      width,
      height,
      depth,
      color,
      texture__);
}

struct ObjectCreateRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ObjectCreateRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROPERTIES = 4,
    VT_OBJECT_TYPE = 6,
    VT_OBJECT = 8
  };
  const ObjectProperties *properties() const {
    return GetPointer<const ObjectProperties *>(VT_PROPERTIES);
  }
  ObjectCreateRequestUnion object_type() const {
    return static_cast<ObjectCreateRequestUnion>(GetField<uint8_t>(VT_OBJECT_TYPE, 0));
  }
  const void *object() const {
    return GetPointer<const void *>(VT_OBJECT);
  }
  template<typename T> const T *object_as() const;
  const ModelCreateRequest *object_as_ModelCreateRequest() const {
    return object_type() == ObjectCreateRequestUnion_ModelCreateRequest ? static_cast<const ModelCreateRequest *>(object()) : nullptr;
  }
  const SphereCreateRequest *object_as_SphereCreateRequest() const {
    return object_type() == ObjectCreateRequestUnion_SphereCreateRequest ? static_cast<const SphereCreateRequest *>(object()) : nullptr;
  }
  const BoxCreateRequest *object_as_BoxCreateRequest() const {
    return object_type() == ObjectCreateRequestUnion_BoxCreateRequest ? static_cast<const BoxCreateRequest *>(object()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PROPERTIES) &&
           verifier.VerifyTable(properties()) &&
           VerifyField<uint8_t>(verifier, VT_OBJECT_TYPE, 1) &&
           VerifyOffset(verifier, VT_OBJECT) &&
           VerifyObjectCreateRequestUnion(verifier, object(), object_type()) &&
           verifier.EndTable();
  }
};

template<> inline const ModelCreateRequest *ObjectCreateRequest::object_as<ModelCreateRequest>() const {
  return object_as_ModelCreateRequest();
}

template<> inline const SphereCreateRequest *ObjectCreateRequest::object_as<SphereCreateRequest>() const {
  return object_as_SphereCreateRequest();
}

template<> inline const BoxCreateRequest *ObjectCreateRequest::object_as<BoxCreateRequest>() const {
  return object_as_BoxCreateRequest();
}

struct ObjectCreateRequestBuilder {
  typedef ObjectCreateRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_properties(::flatbuffers::Offset<ObjectProperties> properties) {
    fbb_.AddOffset(ObjectCreateRequest::VT_PROPERTIES, properties);
  }
  void add_object_type(ObjectCreateRequestUnion object_type) {
    fbb_.AddElement<uint8_t>(ObjectCreateRequest::VT_OBJECT_TYPE, static_cast<uint8_t>(object_type), 0);
  }
  void add_object(::flatbuffers::Offset<void> object) {
    fbb_.AddOffset(ObjectCreateRequest::VT_OBJECT, object);
  }
  explicit ObjectCreateRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ObjectCreateRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ObjectCreateRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ObjectCreateRequest> CreateObjectCreateRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ObjectProperties> properties = 0,
    ObjectCreateRequestUnion object_type = ObjectCreateRequestUnion_NONE,
    ::flatbuffers::Offset<void> object = 0) {
  ObjectCreateRequestBuilder builder_(_fbb);
  builder_.add_object(object);
  builder_.add_properties(properties);
  builder_.add_object_type(object_type);
  return builder_.Finish();
}

struct ObjectCreateAndUpdateRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ObjectCreateAndUpdateRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OBJECT_TYPE = 4,
    VT_OBJECT = 6
  };
  ObjectUpdateRequestUnion object_type() const {
    return static_cast<ObjectUpdateRequestUnion>(GetField<uint8_t>(VT_OBJECT_TYPE, 0));
  }
  const void *object() const {
    return GetPointer<const void *>(VT_OBJECT);
  }
  template<typename T> const T *object_as() const;
  const ModelUpdateRequest *object_as_ModelUpdateRequest() const {
    return object_type() == ObjectUpdateRequestUnion_ModelUpdateRequest ? static_cast<const ModelUpdateRequest *>(object()) : nullptr;
  }
  const SphereUpdateRequest *object_as_SphereUpdateRequest() const {
    return object_type() == ObjectUpdateRequestUnion_SphereUpdateRequest ? static_cast<const SphereUpdateRequest *>(object()) : nullptr;
  }
  const BoxUpdateRequest *object_as_BoxUpdateRequest() const {
    return object_type() == ObjectUpdateRequestUnion_BoxUpdateRequest ? static_cast<const BoxUpdateRequest *>(object()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_OBJECT_TYPE, 1) &&
           VerifyOffset(verifier, VT_OBJECT) &&
           VerifyObjectUpdateRequestUnion(verifier, object(), object_type()) &&
           verifier.EndTable();
  }
};

template<> inline const ModelUpdateRequest *ObjectCreateAndUpdateRequest::object_as<ModelUpdateRequest>() const {
  return object_as_ModelUpdateRequest();
}

template<> inline const SphereUpdateRequest *ObjectCreateAndUpdateRequest::object_as<SphereUpdateRequest>() const {
  return object_as_SphereUpdateRequest();
}

template<> inline const BoxUpdateRequest *ObjectCreateAndUpdateRequest::object_as<BoxUpdateRequest>() const {
  return object_as_BoxUpdateRequest();
}

struct ObjectCreateAndUpdateRequestBuilder {
  typedef ObjectCreateAndUpdateRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_object_type(ObjectUpdateRequestUnion object_type) {
    fbb_.AddElement<uint8_t>(ObjectCreateAndUpdateRequest::VT_OBJECT_TYPE, static_cast<uint8_t>(object_type), 0);
  }
  void add_object(::flatbuffers::Offset<void> object) {
    fbb_.AddOffset(ObjectCreateAndUpdateRequest::VT_OBJECT, object);
  }
  explicit ObjectCreateAndUpdateRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ObjectCreateAndUpdateRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ObjectCreateAndUpdateRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ObjectCreateAndUpdateRequest> CreateObjectCreateAndUpdateRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ObjectUpdateRequestUnion object_type = ObjectUpdateRequestUnion_NONE,
    ::flatbuffers::Offset<void> object = 0) {
  ObjectCreateAndUpdateRequestBuilder builder_(_fbb);
  builder_.add_object(object);
  builder_.add_object_type(object_type);
  return builder_.Finish();
}

struct ObjectUpdateRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ObjectUpdateRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UPDATES = 4,
    VT_ANIMATION = 6,
    VT_ANIMATION_TIME = 8
  };
  const UpdatedObjectProperties *updates() const {
    return GetPointer<const UpdatedObjectProperties *>(VT_UPDATES);
  }
  const ::flatbuffers::String *animation() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ANIMATION);
  }
  float animation_time() const {
    return GetField<float>(VT_ANIMATION_TIME, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UPDATES) &&
           verifier.VerifyTable(updates()) &&
           VerifyOffset(verifier, VT_ANIMATION) &&
           verifier.VerifyString(animation()) &&
           VerifyField<float>(verifier, VT_ANIMATION_TIME, 4) &&
           verifier.EndTable();
  }
};

struct ObjectUpdateRequestBuilder {
  typedef ObjectUpdateRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_updates(::flatbuffers::Offset<UpdatedObjectProperties> updates) {
    fbb_.AddOffset(ObjectUpdateRequest::VT_UPDATES, updates);
  }
  void add_animation(::flatbuffers::Offset<::flatbuffers::String> animation) {
    fbb_.AddOffset(ObjectUpdateRequest::VT_ANIMATION, animation);
  }
  void add_animation_time(float animation_time) {
    fbb_.AddElement<float>(ObjectUpdateRequest::VT_ANIMATION_TIME, animation_time, 0.0f);
  }
  explicit ObjectUpdateRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ObjectUpdateRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ObjectUpdateRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ObjectUpdateRequest> CreateObjectUpdateRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<UpdatedObjectProperties> updates = 0,
    ::flatbuffers::Offset<::flatbuffers::String> animation = 0,
    float animation_time = 0.0f) {
  ObjectUpdateRequestBuilder builder_(_fbb);
  builder_.add_animation_time(animation_time);
  builder_.add_animation(animation);
  builder_.add_updates(updates);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ObjectUpdateRequest> CreateObjectUpdateRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<UpdatedObjectProperties> updates = 0,
    const char *animation = nullptr,
    float animation_time = 0.0f) {
  auto animation__ = animation ? _fbb.CreateString(animation) : 0;
  return CreateObjectUpdateRequest(
      _fbb,
      updates,
      animation__,
      animation_time);
}

struct ObjectPropertiesUpdateRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ObjectPropertiesUpdateRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_POSITION = 6,
    VT_ROTATION = 8,
    VT_SCALING = 10,
    VT_ANIMATION = 12,
    VT_ANIMATION_TIME = 14
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const Vec3 *position() const {
    return GetStruct<const Vec3 *>(VT_POSITION);
  }
  const Vec3 *rotation() const {
    return GetStruct<const Vec3 *>(VT_ROTATION);
  }
  float scaling() const {
    return GetField<float>(VT_SCALING, 1.0f);
  }
  const ::flatbuffers::String *animation() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ANIMATION);
  }
  float animation_time() const {
    return GetField<float>(VT_ANIMATION_TIME, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<Vec3>(verifier, VT_POSITION, 4) &&
           VerifyField<Vec3>(verifier, VT_ROTATION, 4) &&
           VerifyField<float>(verifier, VT_SCALING, 4) &&
           VerifyOffset(verifier, VT_ANIMATION) &&
           verifier.VerifyString(animation()) &&
           VerifyField<float>(verifier, VT_ANIMATION_TIME, 4) &&
           verifier.EndTable();
  }
};

struct ObjectPropertiesUpdateRequestBuilder {
  typedef ObjectPropertiesUpdateRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(ObjectPropertiesUpdateRequest::VT_ID, id);
  }
  void add_position(const Vec3 *position) {
    fbb_.AddStruct(ObjectPropertiesUpdateRequest::VT_POSITION, position);
  }
  void add_rotation(const Vec3 *rotation) {
    fbb_.AddStruct(ObjectPropertiesUpdateRequest::VT_ROTATION, rotation);
  }
  void add_scaling(float scaling) {
    fbb_.AddElement<float>(ObjectPropertiesUpdateRequest::VT_SCALING, scaling, 1.0f);
  }
  void add_animation(::flatbuffers::Offset<::flatbuffers::String> animation) {
    fbb_.AddOffset(ObjectPropertiesUpdateRequest::VT_ANIMATION, animation);
  }
  void add_animation_time(float animation_time) {
    fbb_.AddElement<float>(ObjectPropertiesUpdateRequest::VT_ANIMATION_TIME, animation_time, 0.0f);
  }
  explicit ObjectPropertiesUpdateRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ObjectPropertiesUpdateRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ObjectPropertiesUpdateRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ObjectPropertiesUpdateRequest> CreateObjectPropertiesUpdateRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    const Vec3 *position = nullptr,
    const Vec3 *rotation = nullptr,
    float scaling = 1.0f,
    ::flatbuffers::Offset<::flatbuffers::String> animation = 0,
    float animation_time = 0.0f) {
  ObjectPropertiesUpdateRequestBuilder builder_(_fbb);
  builder_.add_animation_time(animation_time);
  builder_.add_animation(animation);
  builder_.add_scaling(scaling);
  builder_.add_rotation(rotation);
  builder_.add_position(position);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ObjectPropertiesUpdateRequest> CreateObjectPropertiesUpdateRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const Vec3 *position = nullptr,
    const Vec3 *rotation = nullptr,
    float scaling = 1.0f,
    const char *animation = nullptr,
    float animation_time = 0.0f) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto animation__ = animation ? _fbb.CreateString(animation) : 0;
  return CreateObjectPropertiesUpdateRequest(
      _fbb,
      id__,
      position,
      rotation,
      scaling,
      animation__,
      animation_time);
}

struct ObjectDebugRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ObjectDebugRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_RADIUS = 6,
    VT_CENTER = 8,
    VT_MIN = 10,
    VT_MAX = 12
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  float radius() const {
    return GetField<float>(VT_RADIUS, 0.0f);
  }
  const Vec3 *center() const {
    return GetStruct<const Vec3 *>(VT_CENTER);
  }
  const Vec3 *min() const {
    return GetStruct<const Vec3 *>(VT_MIN);
  }
  const Vec3 *max() const {
    return GetStruct<const Vec3 *>(VT_MAX);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<float>(verifier, VT_RADIUS, 4) &&
           VerifyField<Vec3>(verifier, VT_CENTER, 4) &&
           VerifyField<Vec3>(verifier, VT_MIN, 4) &&
           VerifyField<Vec3>(verifier, VT_MAX, 4) &&
           verifier.EndTable();
  }
};

struct ObjectDebugRequestBuilder {
  typedef ObjectDebugRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(ObjectDebugRequest::VT_ID, id);
  }
  void add_radius(float radius) {
    fbb_.AddElement<float>(ObjectDebugRequest::VT_RADIUS, radius, 0.0f);
  }
  void add_center(const Vec3 *center) {
    fbb_.AddStruct(ObjectDebugRequest::VT_CENTER, center);
  }
  void add_min(const Vec3 *min) {
    fbb_.AddStruct(ObjectDebugRequest::VT_MIN, min);
  }
  void add_max(const Vec3 *max) {
    fbb_.AddStruct(ObjectDebugRequest::VT_MAX, max);
  }
  explicit ObjectDebugRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ObjectDebugRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ObjectDebugRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ObjectDebugRequest> CreateObjectDebugRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    float radius = 0.0f,
    const Vec3 *center = nullptr,
    const Vec3 *min = nullptr,
    const Vec3 *max = nullptr) {
  ObjectDebugRequestBuilder builder_(_fbb);
  builder_.add_max(max);
  builder_.add_min(min);
  builder_.add_center(center);
  builder_.add_radius(radius);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ObjectDebugRequest> CreateObjectDebugRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    float radius = 0.0f,
    const Vec3 *center = nullptr,
    const Vec3 *min = nullptr,
    const Vec3 *max = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  return CreateObjectDebugRequest(
      _fbb,
      id__,
      radius,
      center,
      min,
      max);
}

struct Message FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACK = 4,
    VT_DEBUG = 6,
    VT_CONTENT_TYPE = 8,
    VT_CONTENT = 10
  };
  bool ack() const {
    return GetField<uint8_t>(VT_ACK, 0) != 0;
  }
  uint32_t debug() const {
    return GetField<uint32_t>(VT_DEBUG, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *content_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_CONTENT_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *content() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_CONTENT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ACK, 1) &&
           VerifyField<uint32_t>(verifier, VT_DEBUG, 4) &&
           VerifyOffset(verifier, VT_CONTENT_TYPE) &&
           verifier.VerifyVector(content_type()) &&
           VerifyOffset(verifier, VT_CONTENT) &&
           verifier.VerifyVector(content()) &&
           VerifyMessageUnionVector(verifier, content(), content_type()) &&
           verifier.EndTable();
  }
};

struct MessageBuilder {
  typedef Message Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ack(bool ack) {
    fbb_.AddElement<uint8_t>(Message::VT_ACK, static_cast<uint8_t>(ack), 0);
  }
  void add_debug(uint32_t debug) {
    fbb_.AddElement<uint32_t>(Message::VT_DEBUG, debug, 0);
  }
  void add_content_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> content_type) {
    fbb_.AddOffset(Message::VT_CONTENT_TYPE, content_type);
  }
  void add_content(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> content) {
    fbb_.AddOffset(Message::VT_CONTENT, content);
  }
  explicit MessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Message>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Message> CreateMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool ack = false,
    uint32_t debug = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> content_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> content = 0) {
  MessageBuilder builder_(_fbb);
  builder_.add_content(content);
  builder_.add_content_type(content_type);
  builder_.add_debug(debug);
  builder_.add_ack(ack);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Message> CreateMessageDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool ack = false,
    uint32_t debug = 0,
    const std::vector<uint8_t> *content_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *content = nullptr) {
  auto content_type__ = content_type ? _fbb.CreateVector<uint8_t>(*content_type) : 0;
  auto content__ = content ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*content) : 0;
  return CreateMessage(
      _fbb,
      ack,
      debug,
      content_type__,
      content__);
}

inline bool VerifyObjectCreateRequestUnion(::flatbuffers::Verifier &verifier, const void *obj, ObjectCreateRequestUnion type) {
  switch (type) {
    case ObjectCreateRequestUnion_NONE: {
      return true;
    }
    case ObjectCreateRequestUnion_ModelCreateRequest: {
      auto ptr = reinterpret_cast<const ModelCreateRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectCreateRequestUnion_SphereCreateRequest: {
      auto ptr = reinterpret_cast<const SphereCreateRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectCreateRequestUnion_BoxCreateRequest: {
      auto ptr = reinterpret_cast<const BoxCreateRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyObjectCreateRequestUnionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyObjectCreateRequestUnion(
        verifier,  values->Get(i), types->GetEnum<ObjectCreateRequestUnion>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyObjectUpdateRequestUnion(::flatbuffers::Verifier &verifier, const void *obj, ObjectUpdateRequestUnion type) {
  switch (type) {
    case ObjectUpdateRequestUnion_NONE: {
      return true;
    }
    case ObjectUpdateRequestUnion_ModelUpdateRequest: {
      auto ptr = reinterpret_cast<const ModelUpdateRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectUpdateRequestUnion_SphereUpdateRequest: {
      auto ptr = reinterpret_cast<const SphereUpdateRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectUpdateRequestUnion_BoxUpdateRequest: {
      auto ptr = reinterpret_cast<const BoxUpdateRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyObjectUpdateRequestUnionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyObjectUpdateRequestUnion(
        verifier,  values->Get(i), types->GetEnum<ObjectUpdateRequestUnion>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyMessageUnion(::flatbuffers::Verifier &verifier, const void *obj, MessageUnion type) {
  switch (type) {
    case MessageUnion_NONE: {
      return true;
    }
    case MessageUnion_ObjectCreateRequest: {
      auto ptr = reinterpret_cast<const ObjectCreateRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageUnion_ObjectCreateAndUpdateRequest: {
      auto ptr = reinterpret_cast<const ObjectCreateAndUpdateRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageUnion_ObjectUpdateRequest: {
      auto ptr = reinterpret_cast<const ObjectUpdateRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageUnion_ObjectPropertiesUpdateRequest: {
      auto ptr = reinterpret_cast<const ObjectPropertiesUpdateRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageUnion_ObjectDebugRequest: {
      auto ptr = reinterpret_cast<const ObjectDebugRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyMessageUnionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMessageUnion(
        verifier,  values->Get(i), types->GetEnum<MessageUnion>(i))) {
      return false;
    }
  }
  return true;
}

inline const Message *GetMessage(const void *buf) {
  return ::flatbuffers::GetRoot<Message>(buf);
}

inline const Message *GetSizePrefixedMessage(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Message>(buf);
}

inline bool VerifyMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Message>(nullptr);
}

inline bool VerifySizePrefixedMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Message>(nullptr);
}

inline void FinishMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Message> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Message> root) {
  fbb.FinishSizePrefixed(root);
}

#endif  // FLATBUFFERS_GENERATED_MESSAGE_H_
